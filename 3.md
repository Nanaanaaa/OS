# 三

## 0.0

1. CPU资源利用率： $\frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间}$
2. 周转时间：作业完成时间 - 作业提交时间
3. 平均周转时间：  $(\sum_{i = 1} ^ {n}{T_{周转i}}) / n$
4. 带权周转时间： $\frac{作业周转时间}{作业实际运行时间}$
5. 平均带权周转时间： $(\sum_{i = 1} ^ {n}{T_{带权周转i}}) / n$
6. 等待时间： 进程处于等待处理机的时间之和
7. 响应时间：用户首次提交请求到系统首次产生相应所用的时间

## 0.1 调度算法

1. FCFS 先来先服务
2. SJF 短作业优先 平均等待时间、平均周转时间**一定**最少
3. RR：时间片轮转算法 根据FCFS组成就绪队列 用完时间片就下机排队

## 0.2 死锁避免
### 1. 系统安全状态:
   安全序列 $seq$ ：按照序列的顺序为每个进程分配所需要的资源 直至满足每个进程对资源的最大需求，使得每个进程都可以顺序完成  
   系统处于不安全状态可能处于死锁 系统处于安全状态一定不处于死锁
### 2.银行家算法：
   1.  `need = max - allocation;`
   2.  $bank:$  
       1. `if (request[j] <= need[i][j])  go to step 2`
       2. `if (request[j] <= available[j]) go to step 3`
       3. 尝试分配：  
       ```cpp
         available -= request;
         allocation[i][j] += request[j];
         need[i][j] -= request[j];
       ```
       4. 执行安全性算法 如果安全则把资源分配给`P[i]` 否则把尝试分配给作废 让`p[i]` 等待

### 3. 安全性算法

   ```cpp
#include <vector>
#include <cassert>
#include <iostream>

using i64 = int64_t;

constexpr void printMatrix(const std::vector<std::vector<int>>& A) {
    for (int i = 0; i < A.size(); i++) {
        printf("p%d ", i);
        for (int j = 0; j < A[i].size(); j++) {
            printf("%2d ", A[i][j]);
        }
        puts("");
    }
}

constexpr void printSeq(const std::vector<int>& A) {
    printf("[");
    for (int i = 0; i < A.size(); i++) {
        std::cout << A[i];
        if (i + 1 != A.size()) {
            std::cout << ", ";
        }
    }
    puts("]");
}

struct Bank {
    int n, m; // 进程数量， 资源数量
    std::vector<int> available; //可用资源向量 第i类资源的数量
    std::vector<std::vector<int>> max; // 最大需求矩阵 进程i需要j类资源的数量
    std::vector<std::vector<int>> allocation; // 分配矩阵 进程i获得j类资源的数量
    std::vector<std::vector<int>> need; //需求矩阵 进程i还需要j类资源的数量

    // need = max - allocation;

    Bank(int n, int m) :n(n), m(m) {
        max.assign(n, std::vector(m, 0));
        allocation.assign(n, std::vector(m, 0));
        need.assign(n, std::vector(m, 0));
        available.assign(m, 0);
    }

    void initNeed() {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                need[i][j] = max[i][j] - allocation[i][j];
            }
        }
    }

    void print() {
        puts("最大需求矩阵：");
        printMatrix(max);
        puts("-----------------------");

        puts("支配矩阵：");
        printMatrix(allocation);
        puts("-----------------------");

        puts("需求矩阵：");
        printMatrix(need);
        puts("-----------------------");

        puts("可用资源向量");
        printSeq(available);
        puts("-----------------------");
    }

    bool safe() {
        auto work = available;
        std::vector<bool> finish(n);
        std::vector<int> seq; //安全序列

        for (int i = 0; i < n; i++) {
            if (finish[i]) {
                continue;
            }
            int j = 0;
            for (; j < m; j++) {
                if (need[i][j] > work[j]) {
                    break;
                }
            }

            if (j == m) {
                for (int k = 0; k < m; k++) {
                    work[k] += allocation[i][k];
                }
                finish[i] = true;
                seq.push_back(i);
                i = -1; // goBack to step 2
            }
        }

        if (seq.size() == n) { // 所有进程都满足finish[i] = true; 即安全序列的大小等于进程数
            puts("此时刻资源分配情况：");

            puts("安全序列：");
            printSeq(seq);

            work = available;

            puts("work:");
            for (int i = 0; i < n; i++) {
                printf("p%d ", seq[i]);
                for (int j = 0; j < m; j++) {
                    printf("%2d ", work[j]);
                    work[j] += allocation[seq[i]][j];
                }
                puts("");
            }
            puts("---------------");

            puts("need:");
            for (int i = 0; i < n; i++) {
                printf("p%d ", seq[i]);
                for (int j = 0; j < m; j++) {
                    printf("%2d ", need[seq[i]][j]);
                }
                puts("");
            }
            puts("---------------");

            puts("allocation:");
            for (int i = 0; i < n; i++) {
                printf("p%d ", seq[i]);
                for (int j = 0; j < m; j++) {
                    printf("%2d ", allocation[seq[i]][j]);
                }
                puts("");
            }
            puts("---------------");

            puts("work + allocation:");
            work = available;
            for (int i = 0; i < n; i++) {
                printf("p%d ", seq[i]);
                for (int j = 0; j < m; j++) {
                    printf("%2d ", allocation[seq[i]][j] + work[j]);
                    work[j] += allocation[seq[i]][j];
                }
                puts("");
            }
            puts("---------------");
            return true;
        }
        puts("NOT SAFE!");
        return false;
    }

    void work() {
        while (true) {
            std::vector<int> request(m); // 请求资源向量
            puts("输入需要申请资源的进程号(0base):");
            int p;
            scanf("%d", &p);

            puts("输入该进程申请的全部资源:");
            for (int i = 0; i < m; i++) {
                scanf("%d", &request[i]);
            }

            bool ok = true;

            for (int i = 0; i < m; i++) {
                if (request[i] > need[p][i] || request[i] > available[i]) {
                    puts("输入不合法 request大于need/available, 重新输入");
                    ok = false;
                    break;
                }
            }

            if (!ok) {
                continue;
            }

            auto t1 = available;
            auto t2 = allocation[p];
            auto t3 = need[p];

            for (int i = 0; i < m; i++) {
                available[i] -= request[i];
                allocation[p][i] += request[i];
                need[p][i] -= request[i];
            }

            if (safe()) {
                puts("分配成功!");
                break;
            }
            else {
                available = t1;
                allocation[p] = t2;
                need[p] = t3;
            }
        }
    }
};

int main(int agrc, const char* agrv[]) {
    const int n = 5, m = 3;

    Bank bank(n, m);
    bank.max = {
        {7, 5, 3},
        {3, 2, 2},
        {9, 0, 2},
        {2, 2, 2},
        {4, 3, 3}
    };
    bank.allocation = {
        {0, 1, 0},
        {2, 0, 0},
        {3, 0, 2},
        {2, 1, 1},
        {0, 0, 2}
    };
    bank.available = { 3, 3, 2 };

    bank.initNeed();
    puts("t0时刻的资源分配情况:");
    bank.print();

    if (!bank.safe()) {
        throw std::exception();
    }
    bank.work();

    return 0;
}

   ```
## 1.

高级调度：
作用对象：作业
主要任务将外存的作业调入内存，作业调度
主要用于多道批OS分时 注意实时OS没有高级调度系统

低级调度：
作用对象是进程
主要任务为内存中处于就绪态的作业分配处理机
主要用于：多道批、实时、分时OS

引入中级调度是为了提高内存的利用率与系统吞吐量

## 7.

在抢占式调度算法中 抢占的原则：
优先级、短进程有限、时间片原则

## 9.

静态优先级在创建进程时就确定、动态优先级随着时间与环境变化而变
确定优先级的依据：用户要求，进程对CPU/IO等资源的要求，进程类型

## 12.为啥说多级反馈队列调度能较好地满足用户各方面的需求？

多级反馈队列算法每个队列可以设置不同的调度算法，使得短进程在第一队列完成，
而长队列也得到了处理，不会出现长时间得不到处理的现象

## 15.实时系统常用的调度算法有哪些？

1. 最早截止时间：截止时间越早 优先级越高 可以是抢占式或者非抢占式
2. 最低松弛度优先：截止时间减去当前时间，减去所需时间为松弛度，松弛度越低，优先级越高
   松弛度为0 优先级最高

## 17.产生死锁的原因和必要条件 预防死锁

死锁是多个进程持有别的进程所需的资源而自己无法获得所需要的资源而处于僵持阻塞状态
必要条件：不可剥夺 请求和保持 互斥访问 循环等待
主要处理策略：1. 预防 2. 避免 3.检测和解除
预防死锁：破坏死锁产生的四个必要条件
