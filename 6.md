# 第六章 虚拟存储器

## 1. 传统存储管理方式的特征和缺点

1. 一次性：作业必须一次性全部装入内存。

   1. 大作业无法运行
   2. 并发性下降
2. 驻留性：一直驻留在内存中。

   1. 浪费内存资源

## 2. 局部性原理 

1. 时间局部性
2. 空间局部性

## 3. 虚拟存储器的特征

1. 多次性
2. 对换性
3. 虚拟性

## 4. 请求分页存储管理方式：

1. 当访问的信息不在内存中，由操作系统负责将所需信息将外存调入内存，然后继续执行程序（缺页中断机制，请求调页功能）
2. 内存空间不够时，由操作系统负责将内存中暂时用不到的信息换到外存（页面置换功能）
3. 请求页表机制：
   |页号|物理块号|状态位P|访问字段A|修改位M|外存地址|
   |---|-------|------|--------|------|------|
   1.  状态位 `P` 指示该页是否已经调入内存
   2.  访问字段 `A` 记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问
   3.  修改位 `M` （脏位）：标志该页在调入内存后是否被修改过
   4.  外存地址：通常是物理块号
4. 缺页中断机构： 在请求终端机构中，每当要访问的页面不在内存时，产生一个缺页中断，由操作系统的缺页中断处理程序处理中断。此时缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列。**缺页中断属于内终端**
   1. 如果此时内存中有空闲块，则为该进程分配一个空闲块，将所缺页面装入该块，并修改页表中相应的页表项
   2. 如果此时内存中没有空闲块，则由页面置换算法选择一个页面淘汰。若该页面在内存期间被修改过，则要其写回外存
   3. 一条指令执行的时候可能产生多次缺页中断

## 5. 页面置换算法

### 1. 最佳置换算法（OPT）:

    每次选择淘汰的页面将会是以后永不使用或者在未来最长时间不再被使用的页面，这样可以保证缺页率最低(理想化算法，无法实现)

### 2. 先进先出置换算法（FIFO）:

    用一个循环队列来模拟这个过程，每次选择淘汰的页面是最早进入内存的页面，队列的最大长度取决于系统为进程分配了多少个内存块
    Belady 异常： 为进程分配的物理块增长时，缺页率不降反升

### 3. 最近最久未使用置换算法（LRU）:

   1. 实现方法：用页表项的访问字段记录该页面自上次被访问以来所经历的时间 `t` , 当需要淘汰一个页面时，选一个现有页面 `t` 最大的  
   2. 性能好 实现困难，开销大（性能最接近OPT）

### 4. 时钟置换算法（CLOCK/NRU）:

   特点：性能和开销比较均衡

   #### 1: 简单的CLOCK算法：  

   搞成一个循环数组。为每个页面设置一个访问位( $0/1$ 表示最近是否访问过)。当某页被访问过把它的访问位置为1. 当需要淘汰一个页面时，只需要check一下页的访问位。如果 `0` 则换出，如果 `1` 则置为0，则把它置为 `0` 暂时不换出。如果全 `1` 则进行第二轮扫描。

   #### 2：改进型CLOCK：
   只有被淘汰的页面被修改过时，才需要写回外存。（减少 $I/O$ 操作）。优先修改没有被修改过的页面，使用修改位来标记页面有没有被修改过.  
   主要流程:  $(访问位， 修改位)$
   1. 从当前位置扫到第一个 $(0, 0)$ 的帧进行用于替换。本轮不修改任何标志位
   2. 若第一轮扫描失败，则重新扫描，找到第一个 $(0, 1)$ 的帧用于替换。本轮将所有被扫描失败的帧的访问位设置为 $0$
   3. 若第二轮扫描失败，则重新扫描，找到第一个 $(0, 0)$ 的帧用于替换。本轮不修改任何标志位
   4. 若第三轮扫描失败，找到第一个 $(0, 1)$ 的帧用于替换。

## 6. 页面分配置换策略：

* 驻留集：指的是请求分页存储管理中给进程分配的物理块的集合。驻留集大小对多道程序性能影响大
* 固定分配：驻留集大小不变
* 可变分配：驻留集大小可变
* 局部置换：发生缺页的时候只能选进程自己的空闲物理块进行置换
* 全局置换：可以将`OS`中保留的空闲物理块分配给缺页进程 **全局置换必定不可能固定分配**
* 预调页策略：根据局部性原理。主要用于进程的首次调入（运行前调入）
* 请求调页策略：运行期间发现缺页才将所缺页面调入内存(运行时调入) $I/O$ 消耗较大
* 抖动 / 颠簸现象: 频繁的把页面换入换出内存. 原因: 分配给进程的物理块不够
* 工作集: 指的是某段时间间隔里, 进程实际访问页面的集合. 驻留集大小一般不小于工作集大小 

## 7. 内存映射文件mmp:

优点:  
1. 程序员编程更简单
2. 文件 $I/O$全部由操作系统负责和优化
