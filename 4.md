# 第四章

## 1. 临界资源：一次仅允许一个进程使用的资源（打印机）
   对临界资源的访问必须互斥的进行 每个进程中 访问临界资源的那段代码被称为临界区
   ```cpp
   do {
      entry section;       // 进入区
      critical section;    // 临界区
      exit section;        // 退出区
      remainder section;   // 剩余区
   } while (true);
   ```
## 2. 同步：直接制约关系， 进程因为需要在某些位置上协调它们的工作次序而等待
   传递信息而产生的制约关系
## 3. 互斥：间接制约关系， 一个进程进入临界区使用临界资源时 另一个进程必须等待 当占用临界资源的进程退出临界区后，另一进程才被允许访问此临界资源
   为了禁止两个进程同时进入临界区，同步机制应当遵循如下准则： 

   1. 空闲让进 临界区空闲时 可以允许一个请求进入临界区的进程立即进入临界区
   2. 忙则等待 当已有进程进入临界区时，其他视图进入临界区的进程必须等待
   3. 优先等待 对请求访问的进程 应保证能在有限时间之内进入临界区 
   4. 让权等待 当进程不能进入临界区时 应立即释放处理器 防止进程忙等待
   
## 4. 实现临界区互斥的基本方法： 
   1. 软件实现方法：`Perterson's Algorithm`:  
      设置一个变量 $turn$ ，每个进程在先设置自己的标志后再设置 $turn$ 标志，这时再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区.  
      下面以两个进程 $0/1$ 为例
      ```cpp
      bool flag[2];
      bool turn;
      void Perterson(int i) {
         flag[i] = true;                  // 进入区
         const int j = i ^ 1;             
         turn = j;
         while (flag[j] && turn == j) {   // 进入区
            // wait...
         }
         critical section;                // 临界区
         flag[i] = false;                 // 退出区
         remainder section;               // 剩余区
      }
      ```
      一旦`flag[i] = true` 表示他想进入到临界区 此时`turn = j`. 如果此时j已经在临界区里面，那么会跑到`while (flag[i] && turn == j)` 里面
      此时`i`不能顺利进入临界区；如果`j`不在临界区, 那么`i`会进入临界区

      所以是用`flag` 解决临界资源的互斥访问 利用`turn`解决饥饿现象    
   2. 硬件实现方法：  
      1. 中断屏蔽方法:  
      ```
      关中断;
      临界区;
      开中断;
      ```
      2. 指令硬件方法：$TestAndSet$指令 这是一条原子指令 功能是读出指定标志后把该标志设置为真  
      ```cpp
      bool TeatAndSet(bool* lock) {
         bool old = *lock;
         *lock = true;
         return old;
      }
      ```
      使用该指令实现互斥的过程：
      ```cpp
      while (TeatAndSet(&lock));
      进程的临界区代码段...;
      lock = false;
      进程的其他代码段...;
      ```

      使用$swap$指令实现互斥：
      ```cpp
      key = true;
      while (!key) {
         swap(&lock, &key);
      }
      进程的临界区代码段...;
      lock = false;
      进程的其他代码段...;
      ```
## 5. 互斥锁：解决临界区问题最简单的就是互斥锁，一个进程在进入临界区获得锁，离开临界区释放锁  
      `acquire()` 获得锁; `release()`释放锁 这两个都是原子操作
   ```cpp
   void acquire() {
      while (!available) {
         // 忙则等待
      }
      available = false; // 获得锁
   }
   void release() {
      available = true // 释放锁
   }
   ```
## 6. 信号量机制：只能被两个标准原语$wait(S)$ 和 $singal(S)$ 来访问 通常被记为$P/V$操作
   1. 整形信号量：
      ```cpp
      void wait(int S) {
         while (S <= 0) {
            // wait... （*）
         }
         S--；
      }
      void singal(int S) {
         S++;
      }
      ```
   （*） 这个位置只要`S <= 0` 那就不断测试 所以不是让全等待 而是使得进程处于忙而等待的状态  

   2. 记录型信号量 增加了一个进程链表`L` 用于连接所有等待该资源的进程  
   记录型信号量表示为
   ```cpp
      struct semaphore{
         int value;
         process *L;
      };
   ```
   相应的$wait$和$signal$操作如下：
   ```cpp
      void wait(semaphore S) { // 申请资源
         S.value--;
         if (S.value < 0) {
            S.L->add(*this);
            block(S.L);
         }
      }
      // 这里wait 资源分配完毕 block自我阻塞 放弃处理机 让权等待
      void signal(semaphore S) { // 释放资源
         S.value++;
         if (S.value <= 0) {
            process P = L->front();
            L->pop();
            wakeup(P);
         }
      }
      // signal释放资源 如果释放之后仍然阻塞那么调用wakeup原语 把S.L中第一个等待进程唤醒
   ```
   3. 信号量实现同步： 设$S$为$P_1$, $P_2$同步的公共信号量. $x$执行完之后$y$才能执行
   ```cpp
   semaphore S{};
   process P1() {
      x;
      V(S);  // 告诉进程P2语句x已经完成
      ...
   }
   process P2() {
      ...
      P(S);  // check语句x是否完成
      y;
      ...
   }
   ```
   如果$P_2$先执行到$P(S)$时 $S = 0$，执行 $P$操作会把进程$P_2$阻塞，并放入阻塞队列  
   当进程$P_1$中的$x$执行完之后，执行$V$操作 把$P_2$ 从阻塞队列中放回就绪队列，当$P_2$获得处理机时，就得以继续进行  

   4. 信号量实现互斥：
   ```cpp
      semaphore S = 1;
      process P1() {
         ...
         P(S);
         P1的临界区;
         V(S);
         ...
      }
      process P2() {
         ...
         P(S);
         P1的临界区;
         V(S);
         ...
      }
   ```

   5. 信号量实现前驱关系：建图，check前驱是否运行完成
   ```cpp
      semaphore a1{}, a2{}, b1{}, b2{}, c{}, d{}, e{};
      S1() {
         ...;
         V(a1);
         V(a2);
      }
      S2() {
         P(a1);
         ...;
         V(b1);
         V(b2);
      }
      S3() {
         P(a2);
         ...;
         V(c);
      }
      S4() {
         P(b1);
         ...;
         V(d);
      }
      S5() {
         P(b2);
         ...;
         V(e);
      }
      S6() {
         P(c);
         P(d);
         p(e);
         ...;
      }
   ```
## 7. 管程：利用共享数据抽象地表示系统中的共享资源，使用管程进行管理
   每次只允许一个进程进入管程
   ```cpp
      semaphore S;
      monitor Demo {
         void init_code() {
            S = 5;
         }
         void take_away() {
            S--;
            ...
         }
         void give_back() {
            S++;
            ...
         }
      };
   ```
   1. 条件变量：阻塞原因$condition$  
      $x.wait$ : $x$的条件不满足时 正在调用管程的进程调用$x.wait$将自己插入$x$的等待队列，并且释放管程  
      $x.singal$: $x$对应的条件放生了变化, 调用$x.signal$ 唤醒一个因为$x$条件而阻塞的进程

      条件变量的定义：
      ```cpp
         monitor Demo {
            dataStruct S;
            void init_code(){...}
            void take_away() {
               if (S <= 0) {
                  w.wait();
               }
            }
            void give_back() {
               if (wait == true) {
                  x.signal();
               } 
            }
         };
      ``` 
## 8. 同步问题：
   1. 生产者-消费者问题：一组生产者进程和一组消费者进程共享一个初始为空，大小为`n`的缓冲区,只有缓冲区没有满，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空的时候，消费者才能从中取出消息，否则必须等待 一次只允许一个生产者放入消息或者一个消费者从中取出消息.
   ```cpp
   semaphore mutex = 1;
   semaphore empty = n;
   semaphore full = 0;
   void producer() {
      while (true) {
         auto nextp = produce();
         P(empty);
         P(mutex); 
         add(nextp) // to the buffer
         V(mutex);
         V(full);
      }
   }

   void consumer() {
      while (true) {
         P(full);
         P(mutex);
         auto item = buffer.front();
         buffer.pop();
         V(mutex);
         V(empty);
         consume(item);
      }
   }
   ```
   2. 水果问题：
   ```cpp
   semaphore plate = 1, apple = 0, orange = 0;
   void dad() {
      while (true) {
         auto apple = getApple();
         P(plate);
         put(apple); // on the plate
         V(apple);
      }
   }
   void mom() {
      while (true) {
         auto orange = getApple();
         P(plate);
         put(orange); // on the plate
         V(orange);
      }
   }
   void son() {
      while (true) {
         P(orange);
         take an orange from the plate
         V(plate);
         eat(orange);
      }
   }
   void daughter() {
      while (true) {
         P(apple);
         take an apple from the plate
         V(plate);
         eat(apple);
      }
   }
   ```
   3. 读者-写者问题
   ```cpp
   int count = 0;
   semaphore mutex = 1;
   semaphore rw = 1; // 互斥
   semaphore w = 1; // 写优先
   void writer() {
      while (true) {
         p(w);
         P(rw);
         writing();
         V(rw);
         V(w);
      }
   }
   void reader() {
      while (true) {
         P(w);
         P(mutex);
         if (!count) {
            P(rw);
         }
         V(mutex);
         V(w);

         reading();
         P(mutex);
         count--;
         if (!count) {
            V(rw);
         }
         V(mutex);
      }
   }
   ```
   4. 哲学家进餐问题：当且仅当哲学家左右两边的筷子都能用的时候才允许他抓起筷子（反向贪心）
   ```cpp
   constexpr int N = 5;
   std::array<semaphore, N> chopstick;
   chopstick.fill(1);
   void P(int i) {
      do {
         P(mutex);
         P(chopstick[i]);
         P(chopstick[(i + 1) % 5]);
         V(mutex);
         eat();
         V(chopstick[i]);
         V(chopstick[(i + 1) % 5]);
         think();
      } while (true);
   }
   ```
   5. 吸烟者问题
   ```cpp
   int num = 0;
   semaphore offer[3]{}; // 分别对应01 12 20 组合的资源
   semaphore finish{};
   process producer() {
      while (true) {
         num++;
         num %= 3;
         V(offer[num]);
         produce(); // 任取两种材料放在桌子上
         P(finish);
      }
   }
   process consumer1() {
      while (true) {
         P(offer[2]);
         consume1();
         V(finish);
      }
   }
   process consumer2() {
      while (true) {
         P(offer[1]);
         consume2();
         V(finish);
      }
   }
   process consumer3() {
      while (true) {
         P(offer[0]);
         consume3();
         V(finish);
      }
   }
   ```
