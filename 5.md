
# 第五章

  

## 1. 内存的基本知识:

1. 按字节编址：每个存储单元一字节 1B 8位

2. 按字编址 每个存储单元一个字 每个字大小是计算机字长的大小

3. $2^{10}$ = 1k, $2^{20}$ = 1M, $2^{30}$ = 1G

## 2. 内存管理：

0. 程序的链接与装入： 程序的源代码变成可执行文件需要以下几个步骤：

1. 编译 把源代码编译成若干目标模块

2. 链接 把目标模块以及它们所需要的库函数连接在一起，形成一个完整的装入模块

   1. 静态链接

   2. 装入时动态链接

   3. 运行时动态链接

3. 装入 由装入程序将装入模块装入内存运行

   1. 绝对装入：编译时产生绝对地址 (编译器)

   2. 可重定位装入：装入时将逻辑地址转换为物理地址 (早期多道批处理OS)

   3. 动态运行时装入：运行时将逻辑地址转换成物理地址，需设置重定位寄存器（现代OS使用）

优点：可以将程序分配到不连续的存储区，在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存，便于程序段的共享。

1. 内存空间的分配与回收

2. 内存空间的扩充（实现虚拟性）

3. 地址转换：OS负责逻辑地址到物理地址的转换。处理方式：三种装入

4. 存储保护：保证各个进程在自己的内存空间内运行

1. 设置上下限寄存器

2. 利用重定位寄存器、界地址寄存器进行判断

## 3. 覆盖技术：解决程序内存超过物理总和的问题(为了让进程的大小比他分配到的内存空间大)

1. 一个固定区：存放最活跃的程序段，固定区的程序段在运行过程中不会被调入调出

2. 若干覆盖区：

1. 不可能同时被访问程序段可共享一个覆盖区

2. 覆盖区中的程序段在运行过程中会根据需要调入调出

3. 缺点：对用户不透明

## 4. 交换技术：（中级调度的实现技术）
[![1.png](https://i.postimg.cc/15G4nGzC/1.png)](https://postimg.cc/hfGKN7TT)
1. 设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）暂时换出外存等待的状态为挂起态，可以细分为就绪挂起、阻塞挂起两种状态

2. 对换区通常采用连续分配方式 它的 $I/O$ 速度比文件区更快

3. 文件区主要用于存放文件，主要追求存储空间的利用率 采用离散分配方式

4. 交换通常在许多进程运行并且内存吃紧时进行，系统负荷降低就暂停

5. 优先换出阻塞进程

6.  $PCB$ 常驻内存，不会被换出外存

7. 主要在不同进程或作业间进行

## 5. 连续内存分配方式
### 1. 单一连续分配： 
仅支持单道程序，无外部碎片，有内部碎片  
   
### 2. 固定分区分配： 
支持多道程序，无外部碎片，有内部碎片  
   
### 3. 动态分区分配： 
无内部碎片，有外部碎片 外部碎片可用紧凑技术解决 相邻的空闲分区要合并。 
两个数据结构：空闲分区表和空闲分区链   
   有四种算法：
   1. 首次适应算法`(First Fit)`：空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。  
   
   2. 临近适应算法`(Best Fit)`：又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。  
   
   3. 最佳适应算法`(Worst Fit)`：空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免"大材小用"  

   4. 最坏适应算法`(Next Fit)`：空闲分区以容量递减的次序链接，找到第一个能满足要求(即最大的分区) 从中分割一部分存储空间给作业

## 6. 分页存储管理方式（页是信息的物理单位）

### 0.

$\text{页框 = 页帧 = 内存块 = 物理块 = 物理页面}$  

$\text{而页、页面是进程在逻辑上被划分的地址}$


### 1. DS页表：  

页表通常在 $PCB$ 中  
| 页号P | 块号W |
| ----- | ----- |
| 0     | 3     |
| 1     | 6     |
| 2     | 4     |
| ...   | ...   |
| n     | 8     |

实际上并不存放页号，只存内存块号
如果每个页表项占 $K$ 字节，那么 $i$ 号页表项存放地址 $= X + k * i$
### 2. 分页地址中的地址结构：

| 页号P       | 偏移量W        |
| ----------- | -------------- |
| [31,    12] | [11,        0] |

前一部分是页号 $P$ ， 后一部分是偏移量(页内地址) $W$  
32位地址长度时，$[0, 11]$ 位为页内地址， $[12, 31]$ 位为页号   

(类似于数据结构中的分块)

如果给定一个逻辑地址空间地址为 $A$ ， 页面大小为 $L$ , 则页号 $P$ 和页内地址 $d$：

$$P = \lfloor \frac{A}{L} \rfloor$$
$$d = \text{A mod L}$$

### 3. 地址变换机构：
1. 基本地址变换机构：  
   1. 总共访问两次内存：1.查页表 2.访问目标内存单元
   2. $PRT$ ：页表寄存器，存放页表起始地址 $F$ 和页表长度 $M$  
   3. 基本流程：设页面大小为 $L$ , 逻辑地址 $A$ 到物理地址 $E$ 的转换：
      1. 计算页号 $P$ 和页内地址 $W$
      2. 比较 $P$ 和 $M$ 若 $P \geq M$ ,则产生越界中断
      3.  $P$ 对应的页表项地址 = 页表起始地址 + 页号 * 页表项长度， 取出该页表项内容b即为内存块号 
         $$A = X + F * len $$    
      4.  计算 $E = b * L + W$ 用得到的物理地址 $E$ 访存。如果内存块号和页面偏移量是按位存储的，那么两个拼起来就是最终的物理地址
2. 具有快表地址变换机构：
   1. 快表：联想寄存器 $TLB$ 是一种访问速度比内存快很多的高速缓存，用来存放最近访问的页表项的副本。 只存有页表项的副本，而普通 $Cache$ 可能会有其他各种数据的副本
   2. 基本流程：
      1. 算页号和页内地址
      2. 检查页号合法性
      3. 查询快表，如果没有命中再查页表，如果命中就可以直接知道页面存放的内存块号
      4. 根据内存块号与页内地址得到物理地址
   3. 内存有效访问时间 $EAT$ :设访问一次内存的之间为 $t$ 则没有快表的分页存储的 $EAT$ 为: 
   $$\text{EAT = t + t = 2t}$$  
   如果引入快表 设 $\lambda$ 表示查找快表所需时间, $a$ 表示命中率, $t$ 表示访问内存所需时间 则有：
   $$EAT = a * \lambda + (1 - a) * (t + \lambda) + t = 2t + \lambda - t * a$$
3. 两级页表：
   1. 单级页表的问题：难以找到连续的大内存空间存放页表
   2. 解决方法：把页表项拆分成两级页号（就是把页表再分页）
   3. 如果采用多级页表机制，各级页表的大小不能超过一个页面

## 7. 分段存储结构：（段是信息的逻辑单位，段内连续）
   1. 段号的位数决定了每个进程最多可以分成多少个段 $eg$: $2^{16}$ 个段
   2. 段内地址位数决定了每个段的最大长度是多少 $eg$: $2^{16}KB$    
   3. 基本结构：
         
| 段号     | 段内地址 |
| -------- | -------- |
| [31, 16] | [15, 0]  |

2. 段表：   
   
| 段号（可以隐含） | 段长 | 基址（起始地址） |
| ---------------- | ---- | ---------------- |
| ...              | ...  | ...              |

3. 地址变换过程：（要对段内偏移量进行检查）
   1. 根据逻辑地址 $A$ 得到段号 $S$ ，段内地址 $W$
   2. 根据段号是否越界，若 $S \geq M$ , 则产生越界中断
   3. 查询段表找到段表项，段表项的存放地址为 $F + S * len（段表项长度）$
   4. 检查段内地址是否超过段长，若 $W \geq C(段长)$ , 则产生越界中断
   5. 物理地址 $E = b(段基址) + W$

4. 分段比分页更容易实现信息的共享和保护

## 7. 段页式管理结构（分段 + 分页）
   
| 段号（隐含） | 页号 | 业内偏移量 |
| ------------ | ---- | ---------- |
| ...          | ...  | ...        |

1. 段号的位数决定了每个进程最多可以分成多少个段
2. 页号位数决定了每个段最多有多少页
3. 页内偏移量决定了页面大小，内存块大小是多少
4. 地址变换过程：

   0. 段号 $S$ 页号 $P$ ;页内偏移量 $W$ ;段表始址 $F$ ;段表长度 $M$ ;段表项长度 $len$ ;物理地址 $E$

   1. 根据逻辑地址获得 $S$ , $P$ , $W$ 
   2. 判断段号是否越界，若 $S \geq M$ 则产生越界中断
   3. 查询段表，找到对应的段表项，段表项的存放地址为 $F + S * len$ 
   4. 查询页号是否越界，如果 $P$ > 页表长度, 则产生越界中断 （第一次访存，查询段表）
   5. 根据页表存放块号、页号查询页表找到对应页表项（第二次访存，查询页表）
   6. 物理地址 $E = b * L + W$
   7. 访问目标内存单元（第三次访存）  
   
   *. 如果引入快表，则最好仅需一次访存

## 8. 课后题
### 3. 重定位相关：
1. 重定位是将用户程序的逻辑地址转换成绝对地址的过程
2. 采用重定位，可根据内存当前的地址是用情况，将装入模块装入内存的适当位置，并确定装入的物理地址，以保证程序运行时存取指令或数据地址的正确 
### 4. 动态重定位的实现方式：
1. 连续内存分配方式
2. 离散内存分配方式
### 5. 将程序装入内存的方式：
1. 绝对装入方式： 单道程序
2. 重定位装入方式： 多道程序
3. 动态运行时装入方式： 多道程序
### 8. 对换：
1. 引入原因：内存空间紧张时，系统把内存中某些进程换出内存，把外存中某些已经具备运行条件的进程换入内存，提高了内存空间利用率
2. 类型：换入，换出
### 10. 分段系统相比于分页系统更容易实现信息共享和保护的原因：
1. 分页系统的文件存放分散，需要的标示位太多
2. 分段系统段内内容基本一致，只需要一个标志位便可对整个段进行保护

### 13  
1. $2 * t = 0.4 \mu s$
2. $EAT = 0.1 * 0.4 + 0.9 * (0 + 0.2) = 0.22\mu s$
