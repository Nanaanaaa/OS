
# 第五章

  

## 1. 内存的基本知识:

1. 按字节编址：每个存储单元一字节 1B 8位

2. 按字编址 每个存储单元一个字 每个字大小是计算机字长的大小

3. $2^{10}$ = 1k, $2^{20}$ = 1M, $2^{30}$ = 1G

## 2. 内存管理：

0. 程序的链接与装入： 程序的源代码变成可执行文件需要以下几个步骤：

1. 编译 把源代码编译成若干目标模块

2. 链接 把目标模块以及它们所需要的库函数连接在一起，形成一个完整的装入模块

1. 静态链接

2. 装入时动态链接

3. 运行时动态链接

3. 装入 由装入程序将装入模块装入内存运行

1. 绝对装入：编译时产生绝对地址 (编译器)

2. 可重定位装入：装入时将逻辑地址转换为物理地址 (早期多道批处理OS)

3. 动态运行时装入：运行时将逻辑地址转换成物理地址，需设置重定位寄存器（现代OS使用）

优点：可以将程序分配到不连续的存储区，在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存，便于程序段的共享。

1. 内存空间的分配与回收

2. 内存空间的扩充（实现虚拟性）

3. 地址转换：OS负责逻辑地址到物理地址的转换。处理方式：三种装入

4. 存储保护：保证各个进程在自己的内存空间内运行

1. 设置上下限寄存器

2. 利用重定位寄存器、界地址寄存器进行判断

## 3. 覆盖技术：解决程序内存超过物理总和的问题

1. 一个固定区：存放最活跃的程序段，固定区的程序段在运行过程中不会被调入调出

2. 若干覆盖区：

1. 不可能同时被访问程序段可共享一个覆盖区

2. 覆盖区中的程序段在运行过程中会根据需要调入调出

3. 缺点：对用户不透明

## 4. 交换技术：（中级调度的实现技术）
[![1.png](https://i.postimg.cc/15G4nGzC/1.png)](https://postimg.cc/hfGKN7TT)
1. 设计思想：内存空间紧张时，系统将内存中某些进程暂时换出外存，把外存中某些已经具备运行条件的进程换入内存（进程在内存与磁盘间动态调度）暂时换出外存等待的状态为挂起态，可以细分为就绪挂起、阻塞挂起两种状态

2. 对换区通常采用连续分配方式 它的 $I/O$ 速度比文件区更快

3. 文件区主要用于存放文件，主要追求存储空间的利用率 采用离散分配方式

4. 交换通常在许多进程运行并且内存吃紧时进行，系统负荷降低就暂停

5. 优先换出阻塞进程

6.  $PCB$常驻内存，不会被换出外存

7. 主要在不同进程或作业间进行

## 5. 连续内存分配方式
1. 单一连续分配： 仅支持单道程序，无外部碎片，有内部碎片  
   
2. 固定分区分配： 支持多道程序，无外部碎片，有内部碎片  
   
3. 动态分区分配 无内部碎片，有外部碎片 外部碎片可用紧凑技术解决 相邻的空闲分区要合并。    
   有四种算法：
   1. 首次适应算法(First Fit)：空闲分区以地址递增的次序链接。分配内存时，从链首开始顺序查找，找到大小能满足要求的第一个空闲分区分配给作业。  
   
   2. 临近适应算法(Best Fit)：又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。  
   
   3. 最佳适应算法(Worst Fit)：空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免"大材小用"  

   4. 最坏适应算法(Next Fit)：空闲分区以容量递减的次序链接，找到第一个能满足要求(即最大的分区) 从中分割一部分存储空间给作业
